package game.object.custom;

import game.content.miscellaneous.MithrilSeeds;
import game.content.miscellaneous.Teleport;
import game.content.miscellaneous.Web;
import game.content.skilling.Firemaking;
import game.content.skilling.hunter.HunterTrapObjectManager;
import game.log.GameTickLog;
import game.player.Player;
import game.player.PlayerHandler;
import game.player.event.CycleEvent;
import game.player.event.CycleEventContainer;
import game.player.event.CycleEventHandler;
import java.util.ArrayList;
import java.util.List;
import utility.Misc;

/**
 * @author Sanity
 */

public class ObjectManagerServer {

	public static ArrayList<Object> objects = new ArrayList<Object>();

	public ArrayList<Object> toRemove = new ArrayList<Object>();

	public int size() {
		return objects.size();
	}

	public void objectGameTick() {
		GameTickLog.objectTickDuration = System.currentTimeMillis();
		for (Object o : objects) {
			if (o.tick > 0) {
				o.tick--;
				o.onTick();

				if (o.isTransformationUpdateRequired()) {
					o.clearTransformationUpdateRequired();
					spawnGlobalObject(o);
				}
			} else if (o.tick == 0) {
				toRemove.add(o);
			} else if (o.tick == -1) {
				if (o.isTransformationUpdateRequired()) {
					o.clearTransformationUpdateRequired();
					spawnGlobalObject(o);
				}
			}
		}
		List<Object> copyOfToRemove = new ArrayList<>(toRemove);

		for (Object o : copyOfToRemove) {
			if (isObelisk(o.newId)) {
				int index = getObeliskIndex(o.newId);
				if (activated[index]) {
					activated[index] = false;
					teleportObelisk(index);
					coordinatedActivatedObelisk[index] = false;
				}
			}
			o.onRemove();
			spawnNewObjectAfterTimer(o);
			objects.remove(o);
		}
		toRemove.clear();
		GameTickLog.objectTickDuration = System.currentTimeMillis() - GameTickLog.objectTickDuration;
	}

	public void onLogout(Player player) {

	}

	public void spawnNewObjectAfterTimer(Object o) {

		Firemaking.deleteFire(o);
		MithrilSeeds.deletePlant(o);
		Web.webRespawning(o);

		for (int j = 0; j < PlayerHandler.players.length; j++) {
			if (PlayerHandler.players[j] != null) {
				Player loop = PlayerHandler.players[j];
				if (loadForPlayer(o, loop)) {
					loop.getPA().spawnClientObject(o.newId, o.objectX, o.objectY, o.face, o.type);
				}
			}
		}
	}

	// When an object is spawned straight away, such as empty ore, tree stump, throne, obelisk etc.
	public void spawnGlobalObject(Object o) {
		for (int j = 0; j < PlayerHandler.players.length; j++) {
			if (PlayerHandler.players[j] != null) {
				Player loop = PlayerHandler.players[j];
				if (loadForPlayer(o, loop)) {
					loop.getPA().spawnClientObject(o.objectId, o.objectX, o.objectY, o.face, o.type);
				}
			}
		}
	}

	public static void deleteGlobalObjectPacket(int x, int y, int height, int type) {
		for (int j = 0; j < PlayerHandler.players.length; j++) {
			if (PlayerHandler.players[j] != null) {
				Player loop = PlayerHandler.players[j];
				if (loop.playerAssistant.distanceToPoint(x, y) <= 60 && height == loop.getHeight()) {
					loop.getPA().spawnClientObject(-1, x, y, 0, type);
				}
			}
		}
	}

	public void spawnGlobalObject(int objectId, int x, int y, int height, int face, int type) {
		for (int j = 0; j < PlayerHandler.players.length; j++) {
			if (PlayerHandler.players[j] != null) {
				Player loop = PlayerHandler.players[j];
				if (loop.playerAssistant.distanceToPoint(x, y) <= 60 && height == loop.getHeight()) {
					loop.getPA().spawnClientObject(objectId, x, y, face, type);
				}
			}
		}
	}

	/**
	 * @return
	 * 	return the instance of the object, this is for objects generated by the server that constantly change, such as Hunter traps, Doors, Ores, Trees stump, Cabbage picking etc..
	 */
	public Object isServerGeneratedObject(int x, int y, int height) {
		for (Object o : objects) {
			if (o.objectX == x && o.objectY == y && o.height == height) {
				return o;
			}
		}
		return null;
	}

	// Called upon ChangeRegionPacket.
	public void changeRegionPacketClientObjectUpdate(Player player, boolean delay) {

		if (player == null) {
			return;
		}
		if (System.currentTimeMillis() - player.doorAntiSpam < 1300) {
			return;
		}
		player.doorAntiSpam = System.currentTimeMillis();
		if (!delay) {
			for (Object o : objects) {
				if (loadForPlayer(o, player)) {
					player.getPA().spawnClientObject(o.objectId, o.objectX, o.objectY, o.face, o.type);
				}
			}
		} else {
			CycleEventHandler.getSingleton().addEvent(player, new CycleEvent() {
				@Override
				public void execute(CycleEventContainer container) {
					container.stop();
				}

				@Override
				public void stop() {
					for (Object o : objects) {
						if (loadForPlayer(o, player)) {
							player.getPA().spawnClientObject(o.objectId, o.objectX, o.objectY, o.face, o.type);
						}
						else {
							if (o != null) {
								if (player.getPA().distanceToPoint(o.objectX, o.objectY) <= 60 && player.getHeight() != o.height) {
									player.getPA().spawnClientObject(-1, o.objectX, o.objectY, o.face, o.type);
								}
							}
						}
					}
				}
			}, 2);
		}
	}

	public boolean isObelisk(int id) {
		for (int j = 0; j < obeliskIds.length; j++) {
			if (obeliskIds[j] == id)
				return true;
		}
		return false;
	}

	public int[] obeliskIds =
			{14829, 14830, 14827, 14828, 14826, 14831};

	public int[][] obeliskCoords =
			{
					{3154, 3618},
					{3225, 3665},
					{3033, 3730},
					{3104, 3792},
					{2978, 3864},
					{3305, 3914}
			};

	/**
	 * Used for obelisk interface teleport in order.
	 */
	public static int[][] orderedObeliskCoords =
			{
					{2978, 3864}, //44 wild
					{3033, 3730}, // 27 wild
					{3104, 3792}, //35 wild
					{3154, 3618}, // 13 wild multi
					{3225, 3665}, // 19 wild
					{3305, 3914}
			}; //50 wild multi

	public int[] buttonIDs =
			{81118, 81119, 81120, 81121, 81122, 81123};

	public boolean[] activated =
			{false, false, false, false, false, false};

	public boolean[] coordinatedActivatedObelisk =
			{false, false, false, false, false, false};

	public int[][] coordinatedActivatedObeliskCoords = new int[6][2];


	public final static int[] OBELISK_IDS_ORDERED =
			{
					//loc say 44s ice stryke
					14829,
					//lvl 28
					14830,
					14827,
					14828, //cant hear u nub same
					14826,
					14831
			};


	public void startObelisk(int obeliskId, boolean coordinatedObelisk, int forcedTeleportX, int forcedTeleportY) {
		int index = getObeliskIndex(obeliskId);
		if (index >= 0) {
			if (!activated[index]) {
				activated[index] = true;
				if (coordinatedObelisk) {
					coordinatedActivatedObelisk[index] = true;
					coordinatedActivatedObeliskCoords[index][0] = forcedTeleportX;
					coordinatedActivatedObeliskCoords[index][1] = forcedTeleportY;
				}
				new Object(14825, obeliskCoords[index][0], obeliskCoords[index][1], 0, -1, 10, obeliskId, 10);
				new Object(14825, obeliskCoords[index][0] + 4, obeliskCoords[index][1], 0, -1, 10, obeliskId, 10);
				new Object(14825, obeliskCoords[index][0], obeliskCoords[index][1] + 4, 0, -1, 10, obeliskId, 10);
				new Object(14825, obeliskCoords[index][0] + 4, obeliskCoords[index][1] + 4, 0, -1, 10, obeliskId, 10);
			}
		}
	}

	public int getObeliskIndex(int id) {
		for (int j = 0; j < obeliskIds.length; j++) {
			if (obeliskIds[j] == id) {
				return j;
			}
		}
		return -1;
	}

	public void teleportObelisk(int port) {
		int random = Misc.random(5);
		ArrayList<String> list = new ArrayList<String>();
		for (int index = 0; index < 6; index++) {
			if (index == port) {
				continue;
			}
			list.add(index + "");
		}
		random = Integer.parseInt(list.get(Misc.random(list.size() - 1)));
		for (int j = 0; j < PlayerHandler.players.length; j++) {
			if (PlayerHandler.players[j] != null) {
				Player c = PlayerHandler.players[j];
				int xOffset = c.getX() - obeliskCoords[port][0];
				int yOffset = c.getY() - obeliskCoords[port][1];
				if (c.playerAssistant.withInDistance(c.getX(), c.getY(), obeliskCoords[port][0] + 2, obeliskCoords[port][1] + 2, 1)) {
					int teleportX = obeliskCoords[random][0];
					int teleportY = obeliskCoords[random][1];
					if (coordinatedActivatedObelisk[port]) {
						teleportX = coordinatedActivatedObeliskCoords[port][0];
						teleportY = coordinatedActivatedObeliskCoords[port][1];
					}

					/*
					 * coordinatedActivatedObelisk
					 */
					Teleport.startTeleport(c, teleportX + xOffset, teleportY + yOffset, 0, "OBELISK");
				}
			}
		}
	}

	public boolean loadForPlayer(Object o, Player c) {
		if (o == null || c == null) {
			return false;
		}
		return c.playerAssistant.distanceToPoint(o.objectX, o.objectY) <= 60 && c.getHeight() == o.height;
	}

	public boolean addObject(Object o) {
		if (isServerGeneratedObject(o.objectX, o.objectY, o.height) == null) {
			objects.add(o);
			spawnGlobalObject(o);
			return true;
		}
		return false;
	}

	public void addObject1(Player player, Object o) {
		if (isServerGeneratedObject(o.objectX, o.objectY, o.height) == null) {
			player.toRemove.add(o);
			objects.add(o);
			spawnGlobalObject(o);
		}
	}

	/**
	 * Removes an object from the server if an object exists with the same id, x, y, and z.
	 *
	 * @param object the object to be removed.
	 * @return true if an object was removed.
	 */
	public boolean removeObject(Object object) {
		if (object == null) {
			return false;
		}
		return removeObject(object.objectId, object.objectX, object.objectY, object.height);
	}

	/**
	 * Attempts to remove an object at a given position if the position matches and the object id.
	 *
	 * @param id the id of the object.
	 * @param x the x position on the map.
	 * @param y the y position on the map.
	 * @param z the z position on the map.
	 * @return true if an object was removed.
	 */
	public boolean removeObject(int id, int x, int y, int z) {
		Object object = isServerGeneratedObject(x, y, z);

		if (object != null && object.objectId == id) {
			toRemove.add(object);
			return true;
		}
		return false;
	}

	/**
	 * Remove an object that is in the global objects list.
	 */
	public void removeGlobalObject(String uniqueId) {
		for (int index = 0; index < objects.size(); index++) {
			if (objects.get(index).doorUniqueId.equals(uniqueId)) {
				objects.remove(index);
				index--;
			}
		}
	}

	/**
	 * Determines if an object exists in the game world
	 *
	 * @param id the identification value of the object
	 * @param x the x location of the object
	 * @param y the y location of the object
	 * @param height the height location of the object
	 */
	public boolean exists(int id, int x, int y, int height) {
		return objects.stream().anyMatch(object -> object.objectId == id && object.objectX == x && object.objectY == y && object.height == height);
	}


	public boolean exists(int x, int y, int height) {
		return objects.stream().anyMatch(object -> object.objectX == x && object.objectY == y && object.height == height);
	}



}
